# https://github.com/carla-simulator/carla/blob/master/PythonAPI/carla/source/libcarla/SensorData.cpp
from __future__ import annotations
from .actor import Actor
from .blueprint import Color, OpticalFlowPixel
from .geom import Location, Transform, Vector3D
from .map import LaneMarking
from enum import IntEnum
from typing import List
from typing_extensions import Self


class FakeImage:
    @property
    def width(self) -> int:
        raise NotImplementedError

    @property
    def height(self) -> int:
        raise NotImplementedError

    @property
    def fov(self) -> float:
        raise NotImplementedError

    @property
    def raw_data(self) -> bytes:
        raise NotImplementedError


class SensorData:
    """
    Base class for all the objects containing data generated by a carla.Sensor. This objects should be the argument of the function said sensor is listening to, in order to work with them. Each of these sensors needs for a specific type of sensor data. Hereunder is a list of the sensors and their corresponding data.
        - Cameras (RGB, depth and semantic segmentation): carla.Image.
        - Collision detector: carla.CollisionEvent.
        - GNSS sensor: carla.GnssMeasurement.
        - IMU sensor: carla.IMUMeasurement.
        - Lane invasion detector: carla.LaneInvasionEvent.
        - LIDAR sensor: carla.LidarMeasurement.
        - Obstacle detector: carla.ObstacleDetectionEvent.
        - Radar sensor: carla.RadarMeasurement.
        - RSS sensor: carla.RssResponse.
        - Semantic LIDAR sensor: carla.SemanticLidarMeasurement.
    """

    @property
    def frame(self) -> int:
        """
        Frame count when the data was generated.
        """
        raise NotImplementedError

    @property
    def frame_number(self) -> int:
        """deprecated; using `FakeImage.frame_number`"""
        raise NotImplementedError

    @property
    def timestamp(self) -> float:
        """
        Simulation-time when the data was generated.
        """
        raise NotImplementedError

    @property
    def transform(self) -> Transform:
        """
        Sensor's transform when the data was generated.
        """
        raise NotImplementedError


class ColorConverter(IntEnum):
    """
    Class that defines conversion patterns that can be applied to a carla.Image in order to show information provided by carla.Sensor. Depth conversions cause a loss of accuracy, as sensors detect depth as <b>float</b> that is then converted to a grayscale value between 0 and 255. Take a look at the snipet in carla.Sensor.listen to see an example of how to create and save image data for <b>sensor.camera.semantic_segmentation</b>.
    """

    Raw = 0
    """
    No changes applied to the image. Used by the [RGB camera](ref_sensors.md#rgb-camera).
    """
    Depth = 1
    """
    Converts the image to a linear depth map. Used by the [depth camera](ref_sensors.md#depth-camera).
    """
    LogarithmicDepth = 2
    """
    Converts the image to a depth map using a logarithmic scale, leading to better precision for small distances at the expense of losing it when further away.
    """
    CityScapesPalette = 3
    """
    Converts the image to a segmentated map using tags provided by the blueprint library. Used by the [semantic segmentation camera](ref_sensors.md#semantic-segmentation-camera).
    - var_name: Depth
    """


class Image(SensorData):
    """
    Class that defines an image of 32-bit BGRA colors that will be used as initial data retrieved by camera sensors. There are different camera sensors (currently three, RGB, depth and semantic segmentation) and each of these makes different use for the images. Learn more about them [here](ref_sensors.md).
    """

    @property
    def width(self) -> int:
        """
        Image width in pixels.
        """
        raise NotImplementedError

    @property
    def height(self) -> int:
        """
        Image height in pixels.
        """
        raise NotImplementedError

    @property
    def fov(self) -> float:
        """
        Horizontal field of view of the image.
        unit: degrees
        """
        raise NotImplementedError

    @property
    def raw_data(self) -> bytes:
        raise NotImplementedError

    def convert(self, color_converter: ColorConverter) -> None:  # TODO: return
        """
        Converts the image following the `color_converter` pattern.
        """
        raise NotImplementedError

    def save_to_disk(
        self, path: str, color_converter: ColorConverter
    ) -> None:  # TODO: return
        """
        Saves the image to disk using a converter pattern stated as `color_converter`. The default conversion pattern is <b>Raw</b> that will make no changes to the image.
        """
        raise NotImplementedError

    def __len__(self) -> int:
        raise NotImplementedError

    def __iter__(self) -> Self:
        """
        Iterate over the carla.Color that form the image.
        """
        raise NotImplementedError

    def __next__(self) -> Color:  # TODO: verify
        raise NotImplementedError

    def __getitem__(self, pos: int) -> Color:
        raise NotImplementedError

    def __setitem__(self, pos: int, color: Color) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class OpticalFlowImage(SensorData):
    """
    Class that defines an optical flow image of 2-Dimension float (32-bit) vectors representing the optical flow detected in the field of view. The components of the vector represents the displacement of an object in the image plane. Each component outputs values in the normalized range [-2,2] which scales to [-2 size, 2 size] with size being the total resolution in the corresponding component.
    """

    @property
    def width(self) -> int:
        raise NotImplementedError

    @property
    def height(self) -> int:
        """
        Image height in pixels
        """
        raise NotImplementedError

    @property
    def fov(self) -> float:
        """
        Horizontal field of view of the image.
        unit: degrees
        """
        raise NotImplementedError

    @property
    def raw_data(self) -> bytes:
        raise NotImplementedError

    def get_color_coded_flow(self) -> Image:
        """
        Visualization helper. Converts the optical flow image to an RGB image.
        """
        raise NotImplementedError

    def __len__(self) -> int:
        raise NotImplementedError

    def __iter__(self) -> Self:
        """
        Iterate over the carla.OpticalFlowPixel that form the image.
        """
        raise NotImplementedError

    def __next__(self) -> OpticalFlowPixel:  # TODO: verify
        raise NotImplementedError

    def __getitem__(self, pos: int) -> Color:
        raise NotImplementedError

    def __setitem__(self, pos: int, color: Color) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class LidarMeasurement(SensorData):
    """
    Class that defines the LIDAR data retrieved by a <b>sensor.lidar.ray_cast</b>. This essentially simulates a rotating LIDAR using ray-casting. Learn more about this [here](ref_sensors.md#lidar-raycast-sensor).
    """

    @property
    def horizontal_angle(self) -> float:
        """
        Horizontal angle the LIDAR is rotated at the time of the measurement.
        unit: radians
        """
        raise NotImplementedError

    @property
    def channels(self) -> int:
        """
        Number of lasers shot.
        """
        raise NotImplementedError

    @property
    def raw_data(self) -> bytes:
        """
        Received list of 4D points. Each point consists of [x,y,z] coordiantes plus the intensity computed for that point.
        """
        raise NotImplementedError

    def get_point_count(self, channel: int) -> None:  # TODO: return
        """
        Retrieves the number of points sorted by channel that are generated by this measure. Sorting by channel allows to identify the original channel for every point.
        """
        raise NotImplementedError

    def save_to_disk(self, path: str) -> None:  # TODO: return
        """
        Saves the point cloud to disk as a <b>.ply</b> file describing data from 3D scanners. The files generated are ready to be used within [MeshLab](http://www.meshlab.net/), an open source system for processing said files. Just take into account that axis may differ from Unreal Engine and so, need to be reallocated.
        """
        raise NotImplementedError

    def __len__(self) -> int:
        raise NotImplementedError

    def __iter__(self) -> Self:
        """
        Iterate over the carla.LidarDetection retrieved as data.
        """
        raise NotImplementedError

    def __next__(self) -> LidarDetection:  # TODO: verify
        raise NotImplementedError

    def __getitem__(self) -> LidarDetection:
        raise NotImplementedError

    def __setitem__(self, pos: int, detection: LidarDetection) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class SemanticLidarMeasurement(SensorData):
    """
    Class that defines the semantic LIDAR data retrieved by a <b>sensor.lidar.ray_cast_semantic</b>. This essentially simulates a rotating LIDAR using ray-casting. Learn more about this [here](ref_sensors.md#semanticlidar-raycast-sensor).
    """

    @property
    def horizontal_angle(self) -> float:
        """
        Horizontal angle the LIDAR is rotated at the time of the measurement.
        unit: radians
        """
        raise NotImplementedError

    @property
    def channels(self) -> int:
        """
        Number of lasers shot.
        """
        raise NotImplementedError

    @property
    def raw_data(self) -> bytes:
        """
        Received list of raw detection points. Each point consists of [x,y,z] coordinates plus the cosine of the incident angle, the index of the hit actor, and its semantic tag.
        """
        raise NotImplementedError

    def get_point_count(self, channel: int) -> None:  # TODO: return
        """
        Retrieves the number of points sorted by channel that are generated by this measure. Sorting by channel allows to identify the original channel for every point.
        """
        raise NotImplementedError

    def save_to_disk(self, path: str) -> None:  # TODO: return
        """
        Saves the point cloud to disk as a <b>.ply</b> file describing data from 3D scanners. The files generated are ready to be used within [MeshLab](http://www.meshlab.net/), an open-source system for processing said files. Just take into account that axis may differ from Unreal Engine and so, need to be reallocated.
        """
        raise NotImplementedError

    def __len__(self) -> int:
        raise NotImplementedError

    def __iter__(self) -> Self:
        """
        Iterate over the carla.SemanticLidarDetection retrieved as data.
        """
        raise NotImplementedError

    def __next__(self) -> SemanticLidarDetection:
        raise NotImplementedError

    def __getitem__(self, pos: int) -> SemanticLidarDetection:
        raise NotImplementedError

    def __setitem__(self, pos: int, detection: SemanticLidarDetection) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class CollisionEvent(SensorData):
    """
    Class that defines a collision data for <b>sensor.other.collision</b>. The sensor creates one of this for every collision detected which may be many for one simulation step. Learn more about this [here](ref_sensors.md#collision-detector).
    """

    @property
    def actor(self) -> Actor:
        """
        The actor the sensor is attached to, the one that measured the collision.
        """
        raise NotImplementedError

    @property
    def other_actor(self) -> Actor:
        """
        The second actor involved in the collision.
        """
        raise NotImplementedError

    @property
    def normal_impulse(self) -> Vector3D:
        """
        Normal impulse resulting of the collision.
        unit: N*s
        """
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class ObstacleDetectionEvent(SensorData):
    """
    Class that defines the obstacle data for <b>sensor.other.obstacle</b>. Learn more about this [here](ref_sensors.md#obstacle-detector).
    """

    @property
    def actor(self) -> Actor:
        """
        The actor the sensor is attached to.
        """
        raise NotImplementedError

    @property
    def other_actor(self) -> Actor:
        """
        The actor or object considered to be an obstacle.
        """
        raise NotImplementedError

    @property
    def distance(self) -> float:
        """
        Distance between `actor` and `other`.
        unit: meters
        """
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class LaneInvasionEvent(SensorData):
    """
    Class that defines lanes invasion for <b>sensor.other.lane_invasion</b>. It works only client-side and is dependant on OpenDRIVE to provide reliable information. The sensor creates one of this every time there is a lane invasion, which may be more than once per simulation step. Learn more about this [here](ref_sensors.md#lane-invasion-detector).
    """

    @property
    def actor(self) -> Actor:
        """
        Gets the actor the sensor is attached to, the one that invaded another lane.
        """
        raise NotImplementedError

    @property
    def crossed_lane_markings(self) -> List[LaneMarking]:
        """
        List of lane markings that have been crossed and detected by the sensor.
        """
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class GnssMeasurement(SensorData):
    """
    Class that defines the Gnss data registered by a <b>sensor.other.gnss</b>. It essentially reports its position with the position of the sensor and an OpenDRIVE geo-reference.
    """

    @property
    def latitude(self) -> float:
        """
        North/South value of a point on the map.
        unit: degrees
        """
        raise NotImplementedError

    @property
    def longitude(self) -> float:
        """
        West/East value of a point on the map.
        unit: degrees
        """
        raise NotImplementedError

    @property
    def altitude(self) -> float:
        """
        Height regarding ground level.
        unit: meters
        """
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class IMUMeasurement(SensorData):
    """
    Class that defines the data registered by a <b>sensor.other.imu</b>, regarding the sensor's transformation according to the current carla.World. It essentially acts as accelerometer, gyroscope and compass.
    """

    @property
    def accelerometer(self) -> Vector3D:
        """
        Linear acceleration.
        unit: m/s^2
        """
        raise NotImplementedError

    @property
    def gyroscope(self) -> Vector3D:
        """
        Angular velocity.
        unit: rad/s
        """
        raise NotImplementedError

    @property
    def compass(self) -> float:
        """
        Orientation with regard to the North ([0.0, -1.0, 0.0] in Unreal Engine).
        unit: radians
        """
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class RadarMeasurement(SensorData):
    """
    Class that defines and gathers the measures registered by a <b>sensor.other.radar</b>, representing a wall of points in front of the sensor with a distance, angle and velocity in relation to it. The data consists of a carla.RadarDetection array. Learn more about this [here](ref_sensors.md#radar-sensor).
    """

    @property
    def raw_data(self) -> bytes:
        """
        The complete information of the carla.RadarDetection the radar has registered.
        """
        raise NotImplementedError

    def get_detection_count(self) -> None:  # TODO: return
        """
        Retrieves the number of entries generated, same as `__str__()`.
        """
        raise NotImplementedError

    def __len__(self) -> int:
        raise NotImplementedError

    def __iter__(self) -> Self:
        """
        Iterate over the carla.RadarDetection retrieved as data.
        """
        raise NotImplementedError

    def __next__(self) -> RadarDetection:
        raise NotImplementedError

    def __getitem__(self, pos: int) -> RadarDetection:
        raise NotImplementedError

    def __setitem__(self, pos: int, detection: RadarDetection) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class RadarDetection:
    """
    Data contained inside a carla.RadarMeasurement. Each of these represents one of the points in the cloud that a <b>sensor.other.radar</b> registers and contains the distance, angle and velocity in relation to the radar.
    """

    @property
    def velocity(self) -> float:
        """
        The velocity of the detected object towards the sensor.
        unit: m/s
        """
        raise NotImplementedError

    @velocity.setter
    def velocity(self, val: float) -> None:
        raise NotImplementedError

    @property
    def azimuth(self) -> float:
        """
        Azimuth angle of the detection.
        unit: radians
        """
        raise NotImplementedError

    @azimuth.setter
    def azimuth(self, val: float) -> None:
        raise NotImplementedError

    @property
    def altitude(self) -> float:
        """
        Altitude angle of the detection.
        unit: radians
        """
        raise NotImplementedError

    @altitude.setter
    def altitude(self, val: float) -> None:
        raise NotImplementedError

    @property
    def depth(self) -> float:
        """
        Distance from the sensor to the detection position.
        unit: meters
        """
        raise NotImplementedError

    @depth.setter
    def depth(self, val: float) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class LidarDetection:
    """
    Data contained inside a carla.LidarMeasurement. Each of these represents one of the points in the cloud with its location and its asociated intensity.
    """

    @property
    def point(self) -> Location:
        """
        Point in xyz coordinates.
        """
        raise NotImplementedError

    @point.setter
    def point(self, val: Location) -> None:
        raise NotImplementedError

    @property
    def intensity(self) -> float:
        """
        Computed intensity for this point as a scalar value between [0.0 , 1.0].
        """
        raise NotImplementedError

    @intensity.setter
    def intensity(self, val: float) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class SemanticLidarDetection:
    """
    Data contained inside a carla.SemanticLidarMeasurement. Each of these represents one of the points in the cloud with its location, the cosine of the incident angle, index of the object hit, and its semantic tag.
    """

    @property
    def point(self) -> Location:
        """
        [x,y,z] coordinates of the point.
        """
        raise NotImplementedError

    @point.setter
    def point(self, val: Location) -> None:
        raise NotImplementedError

    @property
    def cos_inc_angle(self) -> float:
        """
        Cosine of the incident angle between the ray, and the normal of the hit object.
        """
        raise NotImplementedError

    @cos_inc_angle.setter
    def cos_inc_angle(self, val: float) -> None:
        raise NotImplementedError

    @property
    def object_idx(self) -> int:
        """
        ID of the actor hit by the ray.
        """
        raise NotImplementedError

    @object_idx.setter
    def object_idx(self, val: int) -> None:
        raise NotImplementedError

    @property
    def object_tag(self) -> int:
        """
        Semantic tag](https://carla.readthedocs.io/en/latest/ref_sensors/#semantic-segmentation-camera) of the component hit by the ray.
        """
        raise NotImplementedError

    @object_tag.setter
    def object_tag(self, val: int) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class DVSEvent:
    """
    Class that defines a DVS event. An event is a quadruple, so a tuple of 4 elements, with `x`, `y` pixel coordinate location, timestamp `t` and polarity `pol` of the event. Learn more about them [here](ref_sensors.md).
    """

    @property
    def x(self) -> int:
        """
        X pixel coordinate.
        """
        raise NotImplementedError

    @property
    def y(self) -> int:
        """
        Y pixel coordinate.
        """
        raise NotImplementedError

    @property
    def t(self) -> int:
        """
        Timestamp of the moment the event happened.
        """
        raise NotImplementedError

    @property
    def pol(self) -> bool:
        """
        Polarity of the event. __True__ for positive and __False__ for negative.
        """
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class DVSEventArray(SensorData):
    """
    Class that defines a stream of events in carla.DVSEvent. Such stream is an array of arbitrary size depending on the number of events. This class also stores the field of view, the height and width of the image and the timestamp from convenience. Learn more about them [here](ref_sensors.md).
    """

    @property
    def width(self) -> int:
        """
        Image width in pixels.
        """
        raise NotImplementedError

    @property
    def height(self) -> int:
        """
        Image height in pixels.
        """
        raise NotImplementedError

    @property
    def fov(self) -> float:
        """
        Horizontal field of view of the image.
        unit: degrees
        """
        raise NotImplementedError

    @property
    def raw_data(self) -> bytes:
        raise NotImplementedError

    def __len__(self) -> int:
        raise NotImplementedError

    def __iter__(self) -> Self:
        """
        Iterate over the carla.DVSEvent retrieved as data.
        """
        raise NotImplementedError

    def __next__(self) -> DVSEvent:
        raise NotImplementedError

    def __getitem__(self, pos: int) -> Color:
        raise NotImplementedError

    def __setitem__(self, pos: int, color: Color) -> Color:
        raise NotImplementedError

    def to_image(self) -> List[Color]:
        """
        Converts the image following this pattern: blue indicates positive events, red indicates negative events.
        """
        raise NotImplementedError

    def to_array(self) -> List[List[int]]:
        """
        Converts the stream of events to an array of int values in the following order <code>[x, y, t, pol]</code>.
        """
        raise NotImplementedError

    def to_array_x(self) -> List[int]:
        """
        Returns an array with X pixel coordinate of all the events in the stream.
        """
        raise NotImplementedError

    def to_array_y(self) -> List[int]:
        """
        Returns an array with Y pixel coordinate of all the events in the stream.
        """
        raise NotImplementedError

    def to_array_t(self) -> List[int]:
        """
        Returns an array with the timestamp of all the events in the stream.
        """
        raise NotImplementedError

    def to_array_pol(self) -> List[int]:
        """
        Returns an array with the polarity of all the events in the stream.
        """
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError
